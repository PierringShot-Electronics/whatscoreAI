/**
 * WhatsCore.AI - Maverick Edition
 *
 * Mesaj Controller (Controller) - v4.5.3 (Multimodal, Fayl T…ômizl…ônm…ôsi, Lokal Tarix√ß…ô D…ôst…ôyi)
 * YENƒ∞Lƒ∞K: userInput.media h…ômi≈ü…ô massiv kimi t…ôyin edilir v…ô mesajlarƒ± lokal JSON fayllarƒ±na saxlayƒ±r.
 */
const { getAIResponse } = require("../services/ai");
const mediaProcessor = require("../services/mediaProcessor");
const { logWithTimestamp } = require("../utils/logger");
const fs = require("fs-extra"); // Temporary files-ƒ± silm…ôk √º√ß√ºn import
const { saveHistory } = require("../services/historyManager"); // Lokal fayl …ôsaslƒ± saveHistory funksiyasƒ±nƒ± import etdik

const messageBuffer = {};
const bufferTimeout = (process.env.BUFFER_TIMEOUT_SECONDS || 8) * 1000;

// M√ºv…ôqq…ôti fayllarƒ± izl…ôm…ôk √º√ß√ºn bir massiv
const temporaryFiles = [];

async function replyToMessage(client, chatId, responseText) {
  try {
    if (!responseText || responseText.trim() === "") return;
    const sentMessage = await client.sendMessage(chatId, responseText.trim());
    const sentMessageId = sentMessage.id._serialized;
    logWithTimestamp(
      `‚úÖ Cavab emal edildi v…ô g√∂nd…ôrildi: [${chatId}] | Mesaj ID: [${sentMessageId}]`,
    );

    // Botun g√∂nd…ôrdiyi mesajƒ± lokal tarix√ß…ôy…ô yazmaq
    await saveHistory(
      chatId,
      {
        type: "text",
        content: responseText.trim(),
        sender: "assistant",
        quotedMsgId:
          message.hasQuotedMsg && message.quotedMsg && message.quotedMsg.id
            ? message.quotedMsg.id._serialized
            : null,
      },
      sentMessageId,
    );
  } catch (error) {
    logWithTimestamp(`‚ùå Cavab g√∂nd…ôrm…ô x…ôtasƒ± [${chatId}]:`, error.message);
  }
}

async function flushBuffer(client, chatId) {
  if (!messageBuffer[chatId] || messageBuffer[chatId].messages.length === 0)
    return;
  const { messages } = messageBuffer[chatId];
  const combinedText = messages.join("\n");
  logWithTimestamp(`‚è≥ Buffer bo≈üaldƒ±lƒ±r [${chatId}]: "${combinedText}"`);
  delete messageBuffer[chatId];
  try {
    // D√úZ∆èLƒ∞≈û BURADA: `flushBuffer` √ßaƒüƒ±rƒ±≈üƒ±nda da `media: []` t…ôyin edilir
    const aiResponse = await getAIResponse(
      chatId,
      { text: combinedText, media: [] },
      "chat",
    );
    await replyToMessage(client, chatId, aiResponse);
  } catch (error) {
    logWithTimestamp(`‚ùå Bufferd…ôn AI cavabƒ± alma x…ôtasƒ±:`, error);
    await replyToMessage(
      client,
      chatId,
      "ü§ñ √úzr ist…ôyir…ôm, bir x…ôta ba≈ü verdi.",
    );
  }
}

async function handleMessage(client, message) {
  const chatId = message.from;
  const chat = await message.getChat();
  await chat.sendSeen();

  // Statuslarƒ± v…ô botun √∂z mesajlarƒ±nƒ± ignor edirik, yalnƒ±z istifad…ô√ßi mesajlarƒ±nƒ± saxlayƒ±rƒ±q
  if (message.fromMe || message.isStatus) {
    return;
  }

  // ƒ∞stifd…ô√ßid…ôn g…ôl…ôn mesajƒ± lokal tarix√ß…ôy…ô yazmaq
  await saveHistory(
    chatId,
    {
      type: message.type,
      content: message.body || "",
      sender: "user",
      quotedMsgId:
        message.hasQuotedMsg && message.quotedMsg && message.quotedMsg.id
          ? message.quotedMsg.id._serialized
          : null,
    },
    message.id._serialized,
  );

  if (message.type === "chat" && message.body.trim() !== "") {
    chat.sendStateTyping();
    if (messageBuffer[chatId]?.timer) clearTimeout(messageBuffer[chatId].timer);
    if (!messageBuffer[chatId]) messageBuffer[chatId] = { messages: [] };
    messageBuffer[chatId].messages.push(message.body);
    messageBuffer[chatId].timer = setTimeout(
      () => flushBuffer(client, chatId).finally(() => chat.clearState()),
      bufferTimeout,
    );
    return;
  }

  if (messageBuffer[chatId]) await flushBuffer(client, chatId);

  chat.sendStateTyping();
  // D√úZ∆èLƒ∞≈û BURADA: `userInput.media` h…ômi≈ü…ô bir massiv olaraq ilkinl…ô≈üir
  let userInput = { text: message.body || "", media: [] };
  let contextType = message.type;

  try {
    if (message.hasMedia) {
      const mediaPath = await mediaProcessor.saveMedia(message);
      temporaryFiles.push(mediaPath);

      if (message.type === "video" || message.type === "ptv") {
        const { audioPath, framePaths } =
          await mediaProcessor.processVideo(mediaPath);
        if (audioPath) {
          userInput.media.push({
            path: audioPath,
            mimeType: "audio/mp3", //Bu hisse mp3  yox mpeg idi
            type: "audio",
          });
          temporaryFiles.push(audioPath);
        }
        if (framePaths && framePaths.length > 0) {
          framePaths.forEach((fp) => {
            userInput.media.push({
              path: fp,
              mimeType: "image/png",
              type: "image",
            });
            temporaryFiles.push(fp);
          });
        }
      } else if (message.type === "audio" || message.type === "ptt") {
        userInput.media.push({
          path: mediaPath,
          mimeType: message.mimetype,
          type: "audio",
        });
      } else {
        userInput.media.push({
          path: mediaPath,
          mimeType: message.mimetype,
          type: message.type,
        });
      }
    } else if (message.type === "location") {
      userInput.text = `ƒ∞stifad…ô√ßi bir m…ôkan g√∂nd…ôrdi: Lat: ${message.location.latitude}, Lon: ${message.location.longitude}. Bu m…ôkana …ôn yaxƒ±n servis m…ôrk…ôzini tap.`;
    } else if (message.type === "product") {
      userInput.text = `ƒ∞stifad…ô√ßi bir m…ôhsul sorƒüusu g√∂nd…ôrdi.`;
      if (message.productId) {
        userInput.productId = message.productId;
        userInput.text += ` M…ôhsul ID: ${message.productId}.`;
      }
      if (message.body && message.body.trim() !== "") {
        userInput.text += ` ∆èlav…ô m…ôlumat: "${message.body}"`;
      }
      contextType = "product_query";
    }

    const aiResponse = await getAIResponse(chatId, userInput, contextType);
    await replyToMessage(client, chatId, aiResponse);
  } catch (error) {
    logWithTimestamp(
      `‚ùå Mesaj emalƒ± zamanƒ± √ºmumi x…ôta [${chatId}]:`,
      error.message,
    );
    await replyToMessage(
      client,
      chatId,
      "ü§ñ Mesajƒ±nƒ±zƒ± emal ed…ôrk…ôn g√∂zl…ônilm…ôz bir problem yarandƒ±.",
    );
  } finally {
    chat.clearState();
    await Promise.all(
      temporaryFiles.map((filePath) =>
        fs
          .unlink(filePath)
          .catch((e) =>
            logWithTimestamp(
              `‚ùå M√ºv…ôqq…ôti fayl silinm…ô x…ôtasƒ±: ${filePath}`,
              e.message,
            ),
          ),
      ),
    );
    temporaryFiles.length = 0;
  }
}

module.exports = { handleMessage };
